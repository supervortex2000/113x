From 913506ffcce4bce8cd51c1e91940f104995303a6 Mon Sep 17 00:00:00 2001
From: "ziheng.li" <ziheng.li@amlogic.com>
Date: Mon, 10 Jan 2022 13:52:58 +0800
Subject: [PATCH 3/4] USB: Kernel print warning occasionally [1/1]

PD#SWPL-69363

Problem:
1.Consistent DMA memory is freed in the interrupt context.

Solution:
1.Free memory outside of the interrupt.

Verify:
A113L AD403 Board

Change-Id: I8588c35c73b3e3bd4ba898a26f7b9b222e218a72
Signed-off-by: ziheng.li <ziheng.li@amlogic.com>
---
 drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd.c | 92 ++++++++++++++++++-
 drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd.h |  1 -
 .../usb/dwc_otg/310/dwc_otg_pcd_intr.c        | 24 ++++-
 .../usb/dwc_otg/310/dwc_otg_pcd_linux.c       | 84 ++++++++++++-----
 include/linux/usb/gadget.h                    |  2 +-
 5 files changed, 170 insertions(+), 33 deletions(-)

diff --git a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd.c b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd.c
index aa37d6c6b27a..9d55ffb6fe8e 100644
--- a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd.c
+++ b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd.c
@@ -1036,9 +1036,38 @@ static void dwc_otg_pcd_init_ep(dwc_otg_pcd_t *pcd, dwc_otg_pcd_ep_t *pcd_ep,
 	pcd_ep->dwc_ep.total_len = 0;
 	pcd_ep->dwc_ep.desc_addr = 0;
 	pcd_ep->dwc_ep.dma_desc_addr = 0;
+#ifdef DWC_UTE_PER_IO
+	/* Alloc DMA Descriptors */
+	if (GET_CORE_IF(pcd)->dma_desc_enable) {
+		pcd_ep->dwc_ep.desc_addr =
+		    dwc_otg_ep_alloc_desc_chain(&pcd_ep->
+						dwc_ep.dma_desc_addr,
+						MAX_DMA_DESC_CNT);
+		if (!pcd_ep->dwc_ep.desc_addr) {
+			DWC_WARN("%s, can't allocate DMA descriptor\n",
+				 __func__);
+		}
+	}
+#endif
 	DWC_CIRCLEQ_INIT(&pcd_ep->queue);
 }
 
+#ifdef DWC_UTE_PER_IO
+static void dwc_otg_pcd_deinit_ep(dwc_otg_pcd_t *pcd, dwc_otg_pcd_ep_t *pcd_ep)
+{
+	dwc_otg_dev_dma_desc_t *desc_addr;
+	dwc_dma_t dma_desc_addr;
+	/* Free DMA Descriptors */
+	if (GET_CORE_IF(pcd)->dma_desc_enable) {
+		desc_addr = pcd_ep->dwc_ep.desc_addr;
+		dma_desc_addr = pcd_ep->dwc_ep.dma_desc_addr;
+
+		dwc_otg_ep_free_desc_chain(desc_addr, dma_desc_addr,
+					   MAX_DMA_DESC_CNT);
+	}
+}
+#endif
+
 /**
  * Initialize ep's
  */
@@ -1097,6 +1126,50 @@ static void dwc_otg_pcd_reinit(dwc_otg_pcd_t *pcd)
 	pcd->ep0.dwc_ep.type = DWC_OTG_EP_TYPE_CONTROL;
 }
 
+#ifdef DWC_UTE_PER_IO
+/**
+ * DeInitialize ep's
+ */
+static void dwc_otg_pcd_deinit(dwc_otg_pcd_t *pcd)
+{
+	int i;
+	uint32_t hwcfg1;
+	dwc_otg_pcd_ep_t *ep;
+	int in_ep_cntr, out_ep_cntr;
+	uint32_t num_in_eps = (GET_CORE_IF(pcd))->dev_if->num_in_eps;
+	uint32_t num_out_eps = (GET_CORE_IF(pcd))->dev_if->num_out_eps;
+
+	/**
+	 * DeInitialize the EP0 structure.
+	 */
+	ep = &pcd->ep0;
+	dwc_otg_pcd_deinit_ep(pcd, ep);
+
+	in_ep_cntr = 0;
+	hwcfg1 = (GET_CORE_IF(pcd))->hwcfg1.d32 >> 3;
+	for (i = 1; in_ep_cntr < num_in_eps; i++) {
+		if ((hwcfg1 & 0x1) == 0) {
+			dwc_otg_pcd_ep_t *ep = &pcd->in_ep[in_ep_cntr];
+			in_ep_cntr++;
+			dwc_otg_pcd_deinit_ep(pcd, ep);
+		}
+		hwcfg1 >>= 2;
+	}
+
+	out_ep_cntr = 0;
+	hwcfg1 = (GET_CORE_IF(pcd))->hwcfg1.d32 >> 2;
+	for (i = 1; out_ep_cntr < num_out_eps; i++) {
+		if ((hwcfg1 & 0x1) == 0) {
+			dwc_otg_pcd_ep_t *ep = &pcd->out_ep[out_ep_cntr];
+			out_ep_cntr++;
+			dwc_otg_pcd_deinit_ep(pcd, ep);
+		}
+		hwcfg1 >>= 2;
+	}
+
+}
+#endif
+
 /**
  * This function is called when the SRP timer expires. The SRP should
  * complete within 6 seconds.
@@ -1442,6 +1515,10 @@ void dwc_otg_pcd_remove(dwc_otg_pcd_t *pcd)
 {
 	dwc_otg_dev_if_t *dev_if = GET_CORE_IF(pcd)->dev_if;
 	int i;
+
+#ifdef DWC_UTE_PER_IO
+	dwc_otg_pcd_deinit(pcd);
+#endif
 	if (pcd->core_if->core_params->dev_out_nak) {
 		for (i = 0; i < MAX_EPS_CHANNELS; i++) {
 			DWC_TIMER_CANCEL(pcd->core_if->ep_xfer_timer[i]);
@@ -1774,6 +1851,7 @@ int dwc_otg_pcd_ep_enable(dwc_otg_pcd_t *pcd,
 	if (ep->dwc_ep.type == UE_BULK)
 		ep->dwc_ep.data_pid_start = 0;
 
+#ifndef DWC_UTE_PER_IO
 	/* Alloc DMA Descriptors */
 	if (GET_CORE_IF(pcd)->dma_desc_enable) {
 #ifndef DWC_UTE_PER_IO
@@ -1794,6 +1872,7 @@ int dwc_otg_pcd_ep_enable(dwc_otg_pcd_t *pcd,
 		}
 #endif
 	}
+#endif
 
 	DWC_DEBUGPL(DBG_PCD, "Activate %s: type=%d, mps=%d desc=%p\n",
 		    (ep->dwc_ep.is_in ? "IN" : "OUT"),
@@ -1828,8 +1907,10 @@ int dwc_otg_pcd_ep_disable(dwc_otg_pcd_t *pcd, void *ep_handle)
 {
 	dwc_otg_pcd_ep_t *ep;
 	dwc_irqflags_t flags;
+#ifndef DWC_UTE_PER_IO
 	dwc_otg_dev_dma_desc_t *desc_addr;
 	dwc_dma_t dma_desc_addr;
+#endif
 	gdfifocfg_data_t gdfifocfgbase = {.d32 = 0 };
 	gdfifocfg_data_t gdfifocfg = {.d32 = 0 };
 	fifosize_data_t dptxfsiz = {.d32 = 0 };
@@ -1905,6 +1986,7 @@ int dwc_otg_pcd_ep_disable(dwc_otg_pcd_t *pcd, void *ep_handle)
 		}
 	}
 
+#ifndef DWC_UTE_PER_IO
 	/* Free DMA Descriptors */
 	if (GET_CORE_IF(pcd)->dma_desc_enable) {
 #ifndef DWC_UTE_PER_IO
@@ -1923,9 +2005,12 @@ int dwc_otg_pcd_ep_disable(dwc_otg_pcd_t *pcd, void *ep_handle)
 		}
 #endif
 	}
+#endif
 	DWC_SPINUNLOCK_IRQRESTORE(pcd->lock, flags);
 
+#ifndef DWC_UTE_PER_IO
 out_unlocked:
+#endif
 	DWC_DEBUGPL(DBG_PCD, "%d %s disabled\n", ep->dwc_ep.num,
 		    ep->dwc_ep.is_in ? "IN" : "OUT");
 
@@ -1989,7 +2074,7 @@ int dwc_otg_pcd_xiso_start_next_request(dwc_otg_pcd_t *pcd,
 					dwcep->xiso_frame_num = (dwcep->xiso_bInterval +
 										dwcep->xiso_frame_num) & 0x3FFF;
 				dwcep->desc_addr[i].buf =
-				    req->xiso_dma + ddesc_iso[i].offset;
+				    req->dma + ddesc_iso[i].offset;
 				dwcep->desc_addr[i].status.b_iso_in.txbytes =
 				    ddesc_iso[i].length;
 				dwcep->desc_addr[i].status.b_iso_in.framenum =
@@ -2028,7 +2113,7 @@ int dwc_otg_pcd_xiso_start_next_request(dwc_otg_pcd_t *pcd,
 				dwcep->xiso_frame_num = (dwcep->xiso_bInterval +
 										dwcep->xiso_frame_num) & 0x3FFF;
 				dwcep->desc_addr[i].buf =
-				    req->xiso_dma + ddesc_iso[i].offset;
+				    req->dma + ddesc_iso[i].offset;
 				dwcep->desc_addr[i].status.b_iso_out.rxbytes =
 				    ddesc_iso[i].length;
 				dwcep->desc_addr[i].status.b_iso_out.framenum =
@@ -2168,7 +2253,7 @@ static int dwc_otg_pcd_xiso_create_pkt_descs(dwc_otg_pcd_request_t *req,
 		DWC_ERROR("Failed to allocate isoc descriptors");
 		return -DWC_E_NO_MEMORY;
 	}
-	req->xiso_dma = usb_req->xios_dma;
+
 	/* Initialize the extended request fields */
 	ereq->per_io_frame_descs = ipds;
 	ereq->error_count = 0;
@@ -2274,6 +2359,7 @@ int dwc_otg_pcd_xiso_ep_queue(dwc_otg_pcd_t *pcd, void *ep_handle,
 	req->sent_zlp = zero;
 	req->priv = req_handle;
 
+	ep->dwc_ep.desc_cnt = req->ext_req.pio_pkt_count;
 	ep->dwc_ep.dma_addr = dma_buf;
 	ep->dwc_ep.start_xfer_buff = buf;
 	ep->dwc_ep.xfer_buff = buf;
diff --git a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd.h b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd.h
index a4d906b48488..5036310633e2 100644
--- a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd.h
+++ b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd.h
@@ -149,7 +149,6 @@ typedef struct dwc_otg_pcd_request {
 
 	 DWC_CIRCLEQ_ENTRY(dwc_otg_pcd_request) queue_entry;
 #ifdef DWC_UTE_PER_IO
-	dwc_dma_t xiso_dma;
 	struct dwc_iso_xreq_port ext_req;
 #endif
 } dwc_otg_pcd_request_t;
diff --git a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd_intr.c b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd_intr.c
index 19d879a3530b..841604d463fe 100644
--- a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd_intr.c
+++ b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd_intr.c
@@ -2172,6 +2172,13 @@ static void complete_ep(dwc_otg_pcd_ep_t *ep)
 
 	DWC_DEBUGPL(DBG_PCDV, "%s() %d-%s\n", __func__, ep->dwc_ep.num,
 		    (ep->dwc_ep.is_in ? "IN" : "OUT"));
+#ifdef DWC_UTE_PER_IO
+	if (ep->dwc_ep.type == DWC_OTG_EP_TYPE_ISOC) {
+		if (!ep->stopped)
+			complete_xiso_ep(ep);
+		return;
+	}
+#endif
 
 	/* Get any pending requests */
 	deptsiz.d32 = 0;
@@ -3549,10 +3556,6 @@ static inline void handle_in_ep_disable_intr(dwc_otg_pcd_t *pcd,
 	dwc_ep = &ep->dwc_ep;
 
 	if (dwc_ep->type == DWC_OTG_EP_TYPE_ISOC) {
-#ifdef DWC_UTE_PER_IO
-		if (dwc_ep->is_in)
-			return;
-#endif
 		dwc_otg_flush_tx_fifo(core_if, dwc_ep->tx_fifo_num);
 		complete_ep(ep);
 		return;
@@ -4100,7 +4103,11 @@ do { \
 							}
 							DWC_WRITE_REG32(&dev_if->in_ep_regs[epnum]->diepctl, depctl.d32);
 						}
+#ifdef DWC_UTE_PER_IO
+						dwc_otg_pcd_xiso_start_next_request(ep->pcd, ep, 1);
+#else
 						start_next_request(ep);
+#endif
 					}
 					ep->dwc_ep.frame_num += ep->dwc_ep.bInterval;
 					if (dwc_ep->frame_num > 0x3FFF)	{
@@ -4566,8 +4573,13 @@ do { \
 						if (!req) {
 							DWC_PRINTF("complete_ep 0x%p, req = NULL!\n", ep);
 						} else {
+#ifdef DWC_UTE_PER_IO
+							if (!ep->stopped)
+								complete_xiso_ep(ep);
+#else
 							dwc_otg_request_done(ep, req, 0);
 							start_next_request(ep);
+#endif
 						}
 					} else {
 						DWC_PRINTF("complete_ep 0x%p, ep->queue empty!\n", ep);
@@ -4654,7 +4666,11 @@ do { \
 						DWC_WRITE_REG32(&core_if->dev_if->
 										out_ep_regs[epnum]->doepctl, depctl.d32);
 					}
+#ifdef DWC_UTE_PER_IO
+					dwc_otg_pcd_xiso_start_next_request(ep->pcd, ep, 1);
+#else
 					start_next_request(ep);
+#endif
 					doepmsk.b.outtknepdis = 1;
 					DWC_MODIFY_REG32(&core_if->dev_if->dev_global_regs->doepmsk,
 								 doepmsk.d32, 0);
diff --git a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd_linux.c b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd_linux.c
index e57216dc73b6..ed5c359e7db2 100644
--- a/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd_linux.c
+++ b/drivers/amlogic/usb/dwc_otg/310/dwc_otg_pcd_linux.c
@@ -228,7 +228,7 @@ static struct usb_request *dwc_otg_pcd_alloc_request(struct usb_ep *ep,
 	usb_req->xios_offset = 0;
 	usb_req->xios_count = 0;
 	usb_req->ur_buf = 0;
-	usb_req->ur_dma = DWC_DMA_ADDR_INVALID;
+	usb_req->queue_flush = 1;
 #endif
 	return usb_req;
 }
@@ -377,25 +377,30 @@ static int ep_queue(struct usb_ep *usb_ep, struct usb_request *usb_req,
 	}
 	is_isoc_ep = (ep->dwc_ep.type == DWC_OTG_EP_TYPE_ISOC) ? 1 : 0;
 
-	if (GET_CORE_IF(pcd)->dma_enable) {
-		struct device *dev = &gadget_wrapper->pcd->otg_dev->os_dep.pldev->dev;
-		if (usb_req->length != 0/* && usb_req->dma == DWC_DMA_ADDR_INVALID*/) {
-			dma_addr = dma_map_single(dev, usb_req->buf, usb_req->length,
-					ep->dwc_ep.is_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
-			usb_req->dma = dma_addr;
+#ifdef DWC_UTE_PER_IO
+	if (is_isoc_ep != 1) {
+#endif
+		if (GET_CORE_IF(pcd)->dma_enable) {
+			struct device *dev = &gadget_wrapper->pcd->otg_dev->os_dep.pldev->dev;
+			if (usb_req->length != 0/* && usb_req->dma == DWC_DMA_ADDR_INVALID*/) {
+				dma_addr = dma_map_single(dev, usb_req->buf, usb_req->length,
+						ep->dwc_ep.is_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+				usb_req->dma = dma_addr;
+			}
 		}
-	}
-
 #ifdef DWC_UTE_PER_IO
-	if (is_isoc_ep == 1) {
-		if (usb_req->xios_dma == DWC_DMA_ADDR_INVALID && !usb_req->xios_buf) {
+	} else {
+		if (!usb_req->queue_flush)
+			return 0;
+
+		if (!usb_req->xios_buf) {
 			/*
 			 * DDMA requires 8-byte alignment.
 			 */
 			usb_req->xios_offset = ((usb_req->length / 8) + ((usb_req->length % 8) ? 1 : 0)) * 8;
 			usb_req->xios_count = XISO_MAX_PKT;
 			usb_req->xios_length = usb_req->xios_offset * usb_req->xios_count;
-			usb_req->xios_buf = DWC_DMA_ALLOC_ATOMIC(usb_req->xios_length, &usb_req->xios_dma);
+			usb_req->xios_buf = kzalloc(usb_req->xios_length, GFP_ATOMIC);
 			if (!usb_req->xios_buf) {
 				DWC_ERROR
 					("%s: Failed to allocate memory for dwc_ep xiso_buff\n",
@@ -403,11 +408,17 @@ static int ep_queue(struct usb_ep *usb_ep, struct usb_request *usb_req,
 				return -ENOMEM;
 			}
 			usb_req->ur_buf = usb_req->buf;
-			usb_req->ur_dma = usb_req->dma;
 		}
-		usb_req->dma = usb_req->ur_dma;
-		usb_req->buf = usb_req->ur_buf;
-		retval = dwc_otg_pcd_xiso_ep_queue(pcd, usb_ep, usb_req->buf, dma_addr,
+		if (GET_CORE_IF(pcd)->dma_enable) {
+			struct device *dev = &gadget_wrapper->pcd->otg_dev->os_dep.pldev->dev;
+			if (usb_req->xios_length != 0/* && usb_req->dma == DWC_DMA_ADDR_INVALID*/) {
+				usb_req->xios_dma = dma_map_single(dev, usb_req->xios_buf, usb_req->xios_length,
+						ep->dwc_ep.is_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+			}
+		}
+		usb_req->buf = usb_req->xios_buf;
+		usb_req->dma = usb_req->xios_dma;
+		retval = dwc_otg_pcd_xiso_ep_queue(pcd, usb_ep, usb_req->buf, usb_req->dma,
 			usb_req->length, usb_req->zero, usb_req,
 			gfp_flags == GFP_ATOMIC ? 1 : 0);
 		if (retval)
@@ -457,9 +468,19 @@ static int ep_dequeue(struct usb_ep *usb_ep, struct usb_request *usb_req)
 		return -EINVAL;
 	}
 	if (ep->dwc_ep.type == DWC_OTG_EP_TYPE_ISOC) {
-		usb_req->dma = usb_req->ur_dma;
 		usb_req->buf = usb_req->ur_buf;
-		DWC_DMA_FREE(usb_req->xios_length, usb_req->xios_buf, usb_req->xios_dma);
+		if (usb_req->xios_dma != DWC_DMA_ADDR_INVALID) {
+			struct device *dev = &gadget_wrapper->pcd->otg_dev->os_dep.pldev->dev;
+			dma_unmap_single(dev, usb_req->xios_dma, usb_req->xios_length,
+							ep->dwc_ep.
+							is_in ? DMA_TO_DEVICE :
+							DMA_FROM_DEVICE);
+			usb_req->xios_dma = DWC_DMA_ADDR_INVALID;
+		}
+		if (usb_req->xios_buf) {
+			kfree(usb_req->xios_buf);
+			usb_req->xios_buf = NULL;
+		}
 		usb_req->xios_dma = DWC_DMA_ADDR_INVALID;
 		usb_req->xios_buf = NULL;
 	}
@@ -929,13 +950,33 @@ static int _xisoc_complete(dwc_otg_pcd_t *pcd, void *ep_handle,
 {
 	struct dwc_iso_xreq_port *ereqport = NULL;
 	struct usb_request *req;
+	struct dwc_otg_pcd_ep *ep = NULL;
+	struct device *dev = NULL;
 	int i;
 
 	req = (struct usb_request *)req_handle;
 	ereqport = (struct dwc_iso_xreq_port *)ereq_port;
 
+	ep = ep_from_handle(pcd, ep_handle);
+	if (ep == NULL) {
+		DWC_ERROR("bad pcd ep\n");
+		return -EINVAL;
+	}
+
+	dev = &gadget_wrapper->pcd->otg_dev->os_dep.pldev->dev;
+	if (GET_CORE_IF(pcd)->dma_enable) {
+		if (req->xios_length != 0)
+			dma_unmap_single(dev, req->xios_dma, req->xios_length,
+					ep->dwc_ep.
+					is_in ? DMA_TO_DEVICE :
+					DMA_FROM_DEVICE);
+	}
 	if (req && req->complete) {
 		for (i = 0; i < ereqport->pio_pkt_count; i++) {
+			if (i == (ereqport->pio_pkt_count - 1))
+				req->queue_flush = 1;
+			else
+				req->queue_flush = 0;
 			/* Copy the request data from the portable logic to our request */
 			req->actual =
 			    ereqport->per_io_frame_descs[i].actual_length;
@@ -1008,12 +1049,7 @@ static int _complete(dwc_otg_pcd_t *pcd, void *ep_handle,
 		dev = &gadget_wrapper->pcd->otg_dev->os_dep.pldev->dev;
 
 		ep = ep_from_handle(pcd, ep_handle);
-#ifdef DWC_UTE_PER_IO
-		if (ep->dwc_ep.type == DWC_OTG_EP_TYPE_ISOC) {
-			req->dma = req->ur_dma;
-			req->buf = req->ur_buf;
-		}
-#endif
+
 		if (GET_CORE_IF(pcd)->dma_enable) {
 			if (req->length != 0)
 				dma_unmap_single(dev, req->dma, req->length,
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 6ed8a5dc51b6..f69974881bed 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -116,13 +116,13 @@ struct usb_request {
 	unsigned		actual;
 
 	void			*ur_buf;
-	dma_addr_t		ur_dma;
 
 	void			*xios_buf;
 	dma_addr_t		xios_dma;
 	unsigned		xios_length;
 	unsigned		xios_offset;
 	unsigned		xios_count;
+	unsigned		queue_flush;
 };
 
 /*-------------------------------------------------------------------------*/
-- 
2.31.1

