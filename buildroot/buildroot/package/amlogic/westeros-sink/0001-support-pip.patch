From 315c3b4f990d13e2fe66b5bb18228bf1e6ccfc18 Mon Sep 17 00:00:00 2001
From: Song Zhao <song.zhao@amlogic.com>
Date: Tue, 16 Mar 2021 22:00:21 -0700
Subject: [PATCH 1/3] support pip

---
 westeros-sink/v4l2/westeros-sink-soc.c | 82 +++++++++++++++++++++++++-
 westeros-sink/v4l2/westeros-sink-soc.h |  3 +
 2 files changed, 84 insertions(+), 1 deletion(-)

diff --git a/westeros-sink/v4l2/westeros-sink-soc.c b/westeros-sink/v4l2/westeros-sink-soc.c
index 5d7a2afc..5779045f 100644
--- a/westeros-sink/v4l2/westeros-sink-soc.c
+++ b/westeros-sink/v4l2/westeros-sink-soc.c
@@ -76,6 +76,8 @@ GST_DEBUG_CATEGORY_EXTERN (gst_westeros_sink_debug);
 enum
 {
   PROP_DEVICE= PROP_SOC_BASE,
+  PROP_PIP_VIDEO,
+  PROP_VIDEO_PLANE_SWITCH,
   PROP_FRAME_STEP_ON_PREROLL,
   PROP_LOW_MEMORY_MODE,
   PROP_FORCE_ASPECT_RATIO,
@@ -145,6 +147,7 @@ static WstVideoClientConnection *wstCreateVideoClientConnection( GstWesterosSink
 static void wstDestroyVideoClientConnection( WstVideoClientConnection *conn );
 static void wstSendFlushVideoClientConnection( WstVideoClientConnection *conn );
 static bool wstSendFrameVideoClientConnection( WstVideoClientConnection *conn, int buffIndex );
+static void wstSendLayerVideoClientConnection( WstVideoClientConnection *conn );
 static void wstDecoderReset( GstWesterosSink *sink, bool hard );
 static void wstGetVideoBounds( GstWesterosSink *sink, int *x, int *y, int *w, int *h );
 static void wstSetTextureCrop( GstWesterosSink *sink, int vx, int vy, int vw, int vh );
@@ -279,6 +282,16 @@ void gst_westeros_sink_soc_class_init(GstWesterosSinkClass *klass)
                          "device location",
                          "Location of the device", gDeviceName, G_PARAM_READWRITE));
 
+   g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_VIDEO_PLANE_SWITCH,
+       g_param_spec_boolean ("video-plane-switch", "video-plane-switch",
+           "Switch main and pip video plane",
+           FALSE, G_PARAM_WRITABLE));
+
+   g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_PIP_VIDEO,
+       g_param_spec_boolean ("pip", "pip",
+           "video picture in picture",
+           FALSE, G_PARAM_WRITABLE));
+
    g_object_class_install_property (gobject_class, PROP_FRAME_STEP_ON_PREROLL,
      g_param_spec_boolean ("frame-step-on-preroll",
                            "frame step on preroll",
@@ -420,6 +433,8 @@ gboolean gst_westeros_sink_soc_init( GstWesterosSink *sink )
    sink->soc.mutex= g_mutex_new();
    #endif
 
+   sink->soc.pip= FALSE;
+   sink->soc.switch_video_plane= FALSE;
    sink->soc.sb= 0;
    sink->soc.activeBuffers= 0;
    sink->soc.frameRate= 0.0;
@@ -634,6 +649,18 @@ void gst_westeros_sink_soc_set_property(GObject *object, guint prop_id, const GV
             sink->soc.frameStepOnPreroll= g_value_get_boolean(value);
             break;
          }
+      case PROP_VIDEO_PLANE_SWITCH:
+      {
+         sink->soc.switch_video_plane= g_value_get_boolean(value);
+         GST_WARNING_OBJECT(sink, "switch main video plane %d", sink->soc.switch_video_plane);
+         break;
+      }
+      case PROP_PIP_VIDEO:
+      {
+         sink->soc.pip= g_value_get_boolean(value);
+         GST_WARNING_OBJECT(sink, "pip video enabled %d", sink->soc.pip);
+         break;
+      }
       case PROP_LOW_MEMORY_MODE:
          {
             sink->soc.lowMemoryMode= g_value_get_boolean(value);
@@ -812,6 +839,8 @@ gboolean gst_westeros_sink_soc_ready_to_paused( GstWesterosSink *sink, gboolean
                wl_vpc_destroy( sink->vpc );
                sink->vpc= 0;
             }
+         } else {
+            wstSendLayerVideoClientConnection( sink->soc.conn );
          }
       }
 
@@ -3225,7 +3254,7 @@ static void wstSendHideVideoClientConnection( WstVideoClientConnection *conn, bo
    {
       struct msghdr msg;
       struct iovec iov[1];
-      unsigned char mbody[7];
+      unsigned char mbody[9];
       int len;
       int sentLen;
 
@@ -3402,6 +3431,51 @@ static void wstSendRectVideoClientConnection( WstVideoClientConnection *conn )
    }
 }
 
+static void wstSendLayerVideoClientConnection( WstVideoClientConnection *conn )
+{
+   if ( conn )
+   {
+      struct msghdr msg;
+      struct iovec iov[1];
+      unsigned char mbody[5];
+      int len;
+      int sentLen;
+
+      msg.msg_name= NULL;
+      msg.msg_namelen= 0;
+      msg.msg_iov= iov;
+      msg.msg_iovlen= 1;
+      msg.msg_control= 0;
+      msg.msg_controllen= 0;
+      msg.msg_flags= 0;
+
+      len= 0;
+      mbody[len++]= 'V';
+      mbody[len++]= 'S';
+      mbody[len++]= 2;
+      mbody[len++]= 'N';
+      if (conn->sink->soc.switch_video_plane)
+         mbody[len++]= (conn->sink->soc.pip? 0 : 1);
+      else
+         mbody[len++]= (conn->sink->soc.pip? 1 : 0);
+
+      iov[0].iov_base= (char*)mbody;
+      iov[0].iov_len= len;
+
+      do
+      {
+         sentLen= sendmsg( conn->socketFd, &msg, MSG_NOSIGNAL );
+      }
+      while ( (sentLen < 0) && (errno == EINTR));
+
+      if ( sentLen == len )
+      {
+         GST_LOG("sent pip %d to video server", conn->sink->soc.pip);
+         g_print("sent pip %d to video server\n", conn->sink->soc.pip);
+      }
+   }
+}
+
 #ifdef USE_AMLOGIC_MESON
 static GstElement* wstFindAudioSink( GstWesterosSink *sink )
 {
@@ -3528,6 +3602,12 @@ static void wstSetSessionInfo( GstWesterosSink *sink )
             g_free( clockName );
          }
       }
+
+      if (sink->soc.pip) {
+         sink->soc.syncType= 0;
+         sink->soc.sessionId= 1;//pip session
+      }
+
       if ( (syncTypePrev != sink->soc.syncType) || (sessionIdPrev != sink->soc.sessionId) )
       {
          wstSendSessionInfoVideoClientConnection( sink->soc.conn );
diff --git a/westeros-sink/v4l2/westeros-sink-soc.h b/westeros-sink/v4l2/westeros-sink-soc.h
index 34fa7063..59506fa1 100644
--- a/westeros-sink/v4l2/westeros-sink-soc.h
+++ b/westeros-sink/v4l2/westeros-sink-soc.h
@@ -199,6 +199,9 @@ struct _GstWesterosSinkSoc
    int videoWidth;
    int videoHeight;
 
+   bool pip;
+   bool switch_video_plane;
+
    gboolean haveColorimetry;
    int hdrColorimetry[4];
    gboolean haveMasteringDisplay;
-- 
2.24.1

