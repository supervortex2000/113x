From 1a1e259f51577b8aa1d66bb455559bfb9dd7db45 Mon Sep 17 00:00:00 2001
From: Xueling Li <xueling.li@amlogic.com>
Date: Thu, 3 Dec 2020 08:29:50 +0000
Subject: [PATCH] adapt to widevine16 decryption function

---
 MediaSession.cpp | 180 ++++++++++++++++++++++++-----------------------
 Policy.h         |   9 ++-
 2 files changed, 99 insertions(+), 90 deletions(-)

diff --git a/MediaSession.cpp b/MediaSession.cpp
index bc55964..0cab296 100644
--- a/MediaSession.cpp
+++ b/MediaSession.cpp
@@ -32,6 +32,7 @@
 #define NYI_KEYSYSTEM "keysystem-placeholder"
 
 using namespace std;
+using namespace widevine;
 
 namespace CDMi {
 
@@ -346,9 +347,7 @@ CDMi_RESULT MediaKeySession::Decrypt(
         uint8_t *pbEncrypted;
         uint16_t inClear = 0;
         uint32_t inEncrypted = 0;
-        size_t blockCounter = 0;
-        size_t encryptedOffset = 0;
-        uint8_t *outputBuffer;
+		uint32_t subsampleTotal = 0;
 
         memcpy(&secureHandle, pbDataItr, sizeof(secureHandle));
         pbDataItr += sizeof(secureHandle);
@@ -359,100 +358,105 @@ CDMi_RESULT MediaKeySession::Decrypt(
             + subSampleCount * (sizeof(inClear) + sizeof(inEncrypted));
         cbEncrypted = f_cbData - sizeof(secureHandle) - sizeof(subSampleCount) - sizeof(magic)
             - subSampleCount * (sizeof(inClear) + sizeof(inEncrypted));
-        widevine::Cdm::OutputBuffer output;
-        widevine::Cdm::InputBuffer input;
 
-
-        input.data = pbEncrypted;
-        input.data_length = cbEncrypted;
-        input.key_id = reinterpret_cast<const uint8_t*>((it->first).c_str());
-        input.block_offset = 0;
-        input.key_id_length = (it->first).size();
-        input.iv = m_IV;
-        input.iv_length = sizeof(m_IV);
-
-        if (secureHandle) {
-          input.is_video = true;
-          output.data = reinterpret_cast<uint8_t*>(secureHandle);
-          output.is_secure = true;
-        } else {
-          input.is_video = false;
-          outputBuffer = (uint8_t*) malloc(cbEncrypted * sizeof(uint8_t));
-          output.data = outputBuffer;
-          output.data_offset = 0;
-          output.is_secure = false;
-        }
-        output.data_length = cbEncrypted;
-
-
-        for (int i = 0; i < subSampleCount; i++) {
-          memcpy(&inClear, pbDataItr, sizeof(inClear));
-          pbDataItr += sizeof(inClear);
-          memcpy(&inEncrypted, pbDataItr, sizeof(inEncrypted));
-          pbDataItr += sizeof(inEncrypted);
-          if (inClear > 0) {
-            input.last_subsample = i + 1 == subSampleCount && inEncrypted == 0;
-            input.encryption_scheme = widevine::Cdm::EncryptionScheme::kClear;
-            input.data_length = inClear;
-            if (widevine::Cdm::kSuccess != m_cdm->decrypt(input, output)) {
-              break;
-            }
-            output.data_offset += inClear;
-            input.data += inClear;
-            input.first_subsample = false;
-          }
-
-          if (inEncrypted > 0) {
-            input.last_subsample = i + 1 == subSampleCount;
-            input.encryption_scheme = widevine::Cdm::EncryptionScheme::kAesCtr;
-            input.data_length = inEncrypted;
-            if (widevine::Cdm::kSuccess != m_cdm->decrypt(input, output)) {
-              break;
-            }
-            output.data_offset += inEncrypted;
-            input.data += inEncrypted;
-            input.block_offset += inEncrypted;
-            input.block_offset %= 16;
-
-            encryptedOffset += inEncrypted;
-
-            if (input.encryption_scheme
-                == widevine::Cdm::EncryptionScheme::kAesCtr) {
-              size_t new_block_counter = encryptedOffset / 16;
-              IncrementIv(m_IV, new_block_counter - blockCounter);
-              blockCounter = new_block_counter;
-            }
-            input.first_subsample = false;
-          }
+        Cdm::Sample decryptSample;
+
+        Cdm::Subsample * subsamplesPtr = (Cdm::Subsample *)malloc(subSampleCount*sizeof(Cdm::Subsample));
+        if (subsamplesPtr){
+  			subsampleTotal = 0;
+			for (int i = 0; i < subSampleCount; i++) {
+			  memcpy(&inClear, pbDataItr, sizeof(inClear));
+			  pbDataItr += sizeof(inClear);
+			  memcpy(&inEncrypted, pbDataItr, sizeof(inEncrypted));
+			  pbDataItr += sizeof(inEncrypted);
+			  subsamplesPtr[i].clear_bytes = inClear;
+			  subsamplesPtr[i].protected_bytes = inEncrypted;
+			  subsampleTotal += inClear;
+			  subsampleTotal += inEncrypted;
+			}
+        }else{
+            printf("line %d, malloc subsample memory failed\n", __LINE__);
+            return CDMi_S_FALSE;
         }
+
+        decryptSample.input.iv = m_IV;
+        decryptSample.input.iv_length = sizeof(m_IV);
+        decryptSample.input.data = pbEncrypted;
+        decryptSample.input.data_length = cbEncrypted;
+        decryptSample.input.subsamples = subsamplesPtr;
+        decryptSample.input.subsamples_length = subSampleCount;                                                                                                                                                                 
+        printf("line %d, secureHandle : 0x%x, subSampleCount:%d subsampleTotal %d, cbEncrypted %d\n", __LINE__, secureHandle, subSampleCount, subsampleTotal, cbEncrypted);
         if (secureHandle) {
-          *f_pcbOpaqueClearContent = 0;
-          *f_ppbOpaqueClearContent = pbData;
+          decryptSample.output.data = reinterpret_cast<uint8_t*>(secureHandle);
         } else {
-          *f_pcbOpaqueClearContent = cbEncrypted;
-          *f_ppbOpaqueClearContent = outputBuffer;
+  		  decryptSample.output.data = (uint8_t*) malloc(cbEncrypted * sizeof(uint8_t));
         }
+		decryptSample.output.data_offset = 0;
+		decryptSample.output.data_length = cbEncrypted;
+
+
+        Cdm::DecryptionBatch decryptionBatch;
+        decryptionBatch.key_id = keyId;
+        decryptionBatch.key_id_length = keyIdLength;
+        decryptionBatch.samples = &decryptSample;
+        decryptionBatch.samples_length = 1;
+        decryptionBatch.pattern.encrypted_blocks = 0;
+        decryptionBatch.pattern.clear_blocks = 0;
+        decryptionBatch.is_secure = ((reinterpret_cast<uint8_t*>(secureHandle)) != nullptr);
+        decryptionBatch.is_video = ((reinterpret_cast<uint8_t*>(secureHandle)) != nullptr);
+        decryptionBatch.encryption_scheme = widevine::Cdm::EncryptionScheme::kAesCtr;
+	    if (widevine::Cdm::kSuccess != m_cdm->decrypt(decryptionBatch)) {
+			printf("line:%d decryption failed\n", __LINE__);
+		}else{
+            //printf("line:%d decryption success\n", __LINE__);
+			if (secureHandle) {
+			  *f_pcbOpaqueClearContent = 0;
+			  *f_ppbOpaqueClearContent = pbData;
+			} else {
+			  *f_pcbOpaqueClearContent = cbEncrypted;
+			  *f_ppbOpaqueClearContent = static_cast<uint8_t*>(decryptSample.output.data);
+			}
+		}
+	    free(subsamplesPtr);
         status = CDMi_SUCCESS;
       } else {
-        widevine::Cdm::OutputBuffer output;
-        uint8_t *outputBuffer = (uint8_t*) malloc(f_cbData * sizeof(uint8_t));
-        output.data = outputBuffer;
-        output.data_length = f_cbData;
-        widevine::Cdm::InputBuffer input;
-        input.data = f_pbData;
-        input.data_length = f_cbData;
-        input.key_id = reinterpret_cast<const uint8_t*>((it->first).c_str());
-        input.key_id_length = (it->first).size();
-        input.iv = m_IV;
-        input.iv_length = sizeof(m_IV);
-
-        if (widevine::Cdm::kSuccess == m_cdm->decrypt(input, output)) {
-          /* Return clear content */
-          *f_pcbOpaqueClearContent = output.data_length;
-          *f_ppbOpaqueClearContent = outputBuffer;
+        Cdm::Sample decryptSample;
+
+        Cdm::Subsample decryptSubsample;
+        decryptSubsample.clear_bytes = 0;
+        decryptSubsample.protected_bytes = f_cbData;
+
+        decryptSample.input.iv = m_IV;
+        decryptSample.input.iv_length = sizeof(m_IV);
+        decryptSample.input.data = f_pbData;
+        decryptSample.input.data_length = f_cbData;
+        decryptSample.input.subsamples = &decryptSubsample;
+        decryptSample.input.subsamples_length = 1;
+
+        Cdm::OutputBuffer decryptOutput;
+        decryptSample.output.data = malloc(f_cbData * sizeof(uint8_t));
+        decryptSample.output.data_offset = 0;
+        decryptSample.output.data_length = f_cbData;
+
+        Cdm::DecryptionBatch decryptionBatch;
+        decryptionBatch.key_id = keyId;
+        decryptionBatch.key_id_length = keyIdLength;
+        decryptionBatch.samples = &decryptSample;
+        decryptionBatch.samples_length = 1;
+        decryptionBatch.pattern.encrypted_blocks = 0;
+        decryptionBatch.pattern.clear_blocks = 0;
+        decryptionBatch.is_secure = false;
+        decryptionBatch.is_video = false;
+        decryptionBatch.encryption_scheme = widevine::Cdm::EncryptionScheme::kAesCtr;
+        if (widevine::Cdm::kSuccess == m_cdm->decrypt(decryptionBatch)) {
+          *f_pcbOpaqueClearContent = decryptionBatch.samples[0].output.data_length;
+          *f_ppbOpaqueClearContent = static_cast<uint8_t *>(decryptionBatch.samples[0].output.data);
 
           status = CDMi_SUCCESS;
-        }
+        }else{
+            printf("line:%d decryption failed\n", __LINE__);
+        }   
+
       }
     }
   }
diff --git a/Policy.h b/Policy.h
index 1bc834a..4a06aee 100644
--- a/Policy.h
+++ b/Policy.h
@@ -22,6 +22,10 @@
 
 using namespace wvcdm;
 
+//because libwidevine_ce_cdm_shared.so doesn't export symbol a2bs_hex, kDefaultServerCertificate and kCencInitData are 
+//not referenced by widevine ocdm stack, so I comment out them, otherwise Widevine.drm can not be loaded due to undefined
+//symbol
+/*
 const std::string kDefaultServerCertificate = a2bs_hex(
     "0ABF020803121028703454C008F63618ADE7443DB6C4C8188BE7F99005228E023082010A02"
     "82010100B52112B8D05D023FCC5D95E2C251C1C649B4177CD8D2BEEF355BB06743DE661E3D"
@@ -43,9 +47,10 @@ const std::string kDefaultServerCertificate = a2bs_hex(
     "40383F9C5116D202A20C9229EE969C2519718303B50D0130C3352E06B014D838540F8A0C22"
     "7C0011E0F5B38E4E298ED2CB301EB4564965F55C5D79757A250A4EB9C84AB3E6539F6B6FDF"
     "56899EA29914");
-
+*/
 const std::string kLicenseServer = "http://widevine-proxy.appspot.com/proxy";
 
+/*
 const std::string kCencInitData = a2bs_hex(
     "00000042"                          // blob size
     "70737368"                          // "pssh"
@@ -56,5 +61,5 @@ const std::string kCencInitData = a2bs_hex(
     "08011a0d7769646576696e655f746573"
     "74220f73747265616d696e675f636c69"
     "7031");
-
+*/
 #endif //WV_POLICY_H_
-- 
2.17.1

