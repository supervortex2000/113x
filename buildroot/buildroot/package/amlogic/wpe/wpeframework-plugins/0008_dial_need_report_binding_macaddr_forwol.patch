diff --git a/DIALServer/DIALServer.cpp b/DIALServer/DIALServer.cpp
index ee2751f..cdb34de 100644
--- a/DIALServer/DIALServer.cpp
+++ b/DIALServer/DIALServer.cpp
@@ -18,6 +18,8 @@
  */
 
 #include "DIALServer.h"
+#include <sys/ioctl.h>
+#include <sys/socket.h>
 
 namespace WPEFramework {
 namespace Plugin {
@@ -138,7 +140,7 @@ namespace Plugin {
         // This SHALL NOT be present if neither WoL nor WoWLAN is supported.
         // Moreover real MAC address of the network iface (either wired or wireless one) should be passed
         // where currently Device identifier is passed in MACAddress.
-        // _response->WakeUp = _T("MAC=") + MACAddress + _T(";Timeout=10");
+        _response->WakeUp = _T("MAC=") + MACAddress + _T(";Timeout=10");
         _response->Mode(Web::MARSHAL_UPPERCASE);
 
         if (Link().Open(1000) != Core::ERROR_NONE) {
@@ -269,6 +271,77 @@ namespace Plugin {
         _lock.Unlock();
     }
 
+	/**
+	 * Returns the local hardware address (e.g. MAC address). On macOS the "en0"
+	 * interface is used. On other platforms the first non-loopback interface is
+	 * used.
+	 *
+	 * As a side-effect, the local global ip_addr is also populated.
+	 *
+	 * (Are these choices of interface really the right ones? Seems risky for
+	 * multi-homed systems.)
+	 *
+	 * @return the local hardware address or NULL if it does not exist, cannot
+	 *         be retrieved, or out-of-memory. The caller must free the returned
+	 *         memory.
+	 */
+	static char * get_local_address(char *ip_addr) {
+#define HW_ADDRSTRLEN 18
+		struct ifconf ifc;
+		char buf[4096];
+		char * hw_addr = NULL;
+		int s;
+        unsigned int i;
+		if (-1 == (s = socket(AF_INET, SOCK_DGRAM, 0))) {
+		    perror("socket");
+		    exit(1);
+		}
+		ifc.ifc_len = sizeof(buf);
+		ifc.ifc_buf = buf;
+		if (0 > ioctl(s, SIOCGIFCONF, &ifc)) {
+		    perror("SIOCGIFCONF");
+		    exit(1);
+		}
+		if (ifc.ifc_len == sizeof(buf)) {
+		    fprintf(stderr, "SIOCGIFCONF output too long");
+		    exit(1);
+		}
+		for (i = 0; i < ifc.ifc_len/sizeof(ifc.ifc_req[0]); i++) {
+		    strncpy(ip_addr,
+		           inet_ntoa(((struct sockaddr_in *)(&ifc.ifc_req[i].ifr_addr))->sin_addr), sizeof(ip_addr) - 1);
+		    if (0 > ioctl(s, SIOCGIFFLAGS, &ifc.ifc_req[i])) {
+		        perror("SIOCGIFFLAGS");
+		        exit(1);
+		    }
+		    if (ifc.ifc_req[i].ifr_flags & IFF_LOOPBACK) {
+		        // don't use loopback interfaces
+		        continue;
+		    }
+		    if (0 > ioctl(s, SIOCGIFHWADDR, &ifc.ifc_req[i])) {
+		        perror("SIOCGIFHWADDR");
+		        exit(1);
+		    }
+		    // FIXME: How do I figure out what type of interface this is in order to
+		    // cast the struct sockaddr ifr_hraddr to the proper type and extract the
+		    // hardware address?
+		    //
+		    // Make sure this is correct for the target device and platform.
+		    hw_addr = (char*)malloc(HW_ADDRSTRLEN + 1);
+		    if (hw_addr == NULL)
+		        break;
+		    sprintf(hw_addr, "%02x:%02x:%02x:%02x:%02x:%02x",
+		            (unsigned char)ifc.ifc_req[i].ifr_hwaddr.sa_data[0],
+		            (unsigned char)ifc.ifc_req[i].ifr_hwaddr.sa_data[1],
+		            (unsigned char)ifc.ifc_req[i].ifr_hwaddr.sa_data[2],
+		            (unsigned char)ifc.ifc_req[i].ifr_hwaddr.sa_data[3],
+		            (unsigned char)ifc.ifc_req[i].ifr_hwaddr.sa_data[4],
+		            (unsigned char)ifc.ifc_req[i].ifr_hwaddr.sa_data[5]);
+		    break;
+		}
+		close(s);
+		return hw_addr;
+	}
+
     /* virtual */ const string DIALServer::Initialize(PluginHost::IShell* service)
     {
         string result;
@@ -293,7 +366,10 @@ namespace Plugin {
 
             // TODO: THis used to be the MAC, but I think  it is just a unique number, otherwise, we need the MAC
             //       that goes with the selectedNode !!!!
-            _dialServiceImpl = new DIALServerImpl(deviceId, _dialURL.Text(), _DefaultAppInfoPath);
+            //_dialServiceImpl = new DIALServerImpl(deviceId, _dialURL.Text(), _DefaultAppInfoPath);
+
+			char* ipaddr = const_cast<char*>(selectedNode.HostAddress().c_str());
+            _dialServiceImpl = new DIALServerImpl(get_local_address(ipaddr), _dialURL.Text(), _DefaultAppInfoPath);
 
             ASSERT(_dialServiceImpl != nullptr);
 
